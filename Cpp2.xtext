grammar org.Cpp2 with org.eclipse.xtext.common.Terminals

generate cpp2 "http://www.Cpp2.org"
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

Test:
	(elements += Declaration)*;

// lex.charset
terminal fragment HEX_QUAD:
	HEXADECIMAL_DIGIT HEXADECIMAL_DIGIT HEXADECIMAL_DIGIT HEXADECIMAL_DIGIT;

terminal fragment UNIVERSAL_CHARACTER_NAME:
	'\\u' HEX_QUAD | '\\U' HEX_QUAD HEX_QUAD;

/* 
 * It makes no sense to pre-process the file during compilation.

// lex.pptoken
PreProcessingToken:
	HEADER_NAME |
	ID |
	INT |
	FLOATING_LITERAL |
	PP_NUMBER |
	CHARACTER_LITERAL |
	STRING_LITERAL |
	PREPROCESSING_OP_OR_PUNC
	// each non-white-space character that cannot be one of the above [ambiguity!!!]
; 

// lex.header
terminal HEADER_NAME:
	'<' H_CHAR+ '>' | '\"' Q_CHAR+ '\"';
 
terminal fragment H_CHAR:
	!('\n' | '>');

terminal fragment Q_CHAR:
	!('\n' | '\"');

// lex.ppnumber
terminal PP_NUMBER:
	(DIGIT | '.' DIGIT) (DIGIT | NONDIGIT | UNIVERSAL_CHARACTER_NAME | ('e' | 'E') ('+' | '-') | '.')*;

*/

// lex.token
Token:
	KEYWORD |
	Literal |
	PREPROCESSING_OP_OR_PUNC
	ID;
	
// lex.key
terminal KEYWORD:
	'alignas' |
	'alignof' |
	'asm' |
	'auto' |
	'bool' |
	'break' |
	'case' |
	'catch' |
	'char' |
	'char16_t' |
	'char32_t' |
	'class' |
	'const' |
	'constexpr' |
	'const_cast' |
	'continue' |
	'decltype' |
	'default' |
	'delete' |
	'do' |
	'double' |
	'dynamic_cast' |
	'else' |
	'enum' |
	'explicit' |
	'export' |
	'extern' |
	'false' |
	'float' |
	'for' |
	'friend' |
	'goto' |
	'if' |
	'inline' |
	'int' |
	'long' |
	'mutable' |
	'namespace' |
	'new' |
	'noexcept' |
	'nullptr' |
	'operator' |
	'private' |
	'protected' |
	'public' |
	'register' |
	'reinterpret_cast' |
	'return' |
	'short' |
	'signed' |
	'sizeof' |
	'static' |
	'static_assert' |
	'static_cast' |
	'struct' |
	'switch' |
	'template' |
	'this' |
	'thread_local' |
	'throw' |
	'true' |
	'try' |
	'typedef' |
	'typeid' |
	'typename' |
	'union' |
	'unsigned' |
	'using' |
	'virtual' |
	'void' |
	'volatile' |
	'wchar_t' |
	'while';

// lex.operators
terminal PREPROCESSING_OP_OR_PUNC:
	'{' |
	'}' |
	'[' |
	']' |
	'#' |
	'##' |
	'(' |
	')' |
	'<:' |
	':>' |
	'<%' |
	'%>' |
	'%:' |
	'%:%:' |
	';' |
	':' |
	'...' |
	'new' |
	'delete' |
	'?' |
	'::' |
	'.' |
	'.*' |
	'+' |
	'-' |
	'*' |
	'/' |
	'%' |
	'^' |
	'&' |
	'|' |
	'~' |
	'!' |
	'=' |
	'<' |
	'>' |
	'+=' |
	'-=' |
	'*=' |
	'/=' |
	'%=' |
	'^=' |
	'&=' |
	'|=' |
	'<<' |
	'>>' |
	'<<=' |
	'>>=' |
	'==' |
	'!=' |
	'<=' |
	'>=' |
	'&&' |
	'||' |
	'++' |
	'--' |
	',' |
	'->*' |
	'->' |
	'and' |
	'and_eq' |
	'bitand' |
	'bitor' |
	'compl' |
	'not' |
	'not_eq' |
	'or' |
	'or_eq' |
	'xor' |
	'xor_eq';

// lex.name
terminal ID:
	(NONDIGIT | UNIVERSAL_CHARACTER_NAME) (DIGIT | NONDIGIT | UNIVERSAL_CHARACTER_NAME)*;

terminal fragment NONDIGIT:
	'a'..'z' | 'A'..'Z' | '_';

terminal fragment DIGIT:
	'0'..'9';

// lex.literal.kinds
Literal:
	INT |
	CHARACTER_LITERAL |
	FLOATING_LITERAL |
	STRING_LITERAL |
	('true' | 'false')
	'nullptr';

// lex.icon
terminal INT returns ecore::EInt:
	(DECIMAL_LITERAL | OCTAL_LITERAL | HEXADECIMAL_LITERAL) INTEGER_SUFFIX?;
	
terminal fragment DECIMAL_LITERAL:
	'1'..'9' DIGIT*;
	
terminal fragment OCTAL_LITERAL:
	'0' OCTAL_DIGIT*;
	
terminal fragment HEXADECIMAL_LITERAL:
	('0x' | '0X') HEXADECIMAL_DIGIT+;
	
terminal fragment OCTAL_DIGIT:
	'0'..'7';
	
terminal fragment HEXADECIMAL_DIGIT:
	'0'..'9' | 'A'..'F';

terminal fragment INTEGER_SUFFIX:
	('u' | 'U') ('l' | 'L' | 'll' | 'LL')? |
	('l' | 'L' | 'll' | 'LL') ('u' | 'U')?;

// lex.ccon
terminal CHARACTER_LITERAL:
	('u' | 'U' | 'L')? '\'' C_CHAR+ '\'';
	
terminal fragment C_CHAR:
	!('\'' | '\\' | '\n') | ESCAPE_SEQUENCE | UNIVERSAL_CHARACTER_NAME;
	
terminal fragment ESCAPE_SEQUENCE:
	SIMPLE_ESCAPE_SEQUENCE | OCTAL_ESCAPE_SEQUENCE | HEXADECIMAL_ESCAPE_SEQUENCE;
	
terminal fragment SIMPLE_ESCAPE_SEQUENCE:
	'\\' ('\'' | '\"' | '?' | '\\' | 'a' | 'b' | 'f' | 'n' | 'r' | 't' | 'v');
	
terminal fragment OCTAL_ESCAPE_SEQUENCE:
	'\\' OCTAL_DIGIT OCTAL_DIGIT OCTAL_DIGIT;
	
terminal fragment HEXADECIMAL_ESCAPE_SEQUENCE:
	'\\x' HEXADECIMAL_DIGIT+;

// lex.fcon
terminal FLOATING_LITERAL:
	(FRACTIONAL_CONSTANT EXPONENT_PART? | DIGIT+ EXPONENT_PART) ('f' | 'l' | 'F' | 'L')?;

terminal fragment FRACTIONAL_CONSTANT:
	DIGIT* '.' DIGIT+ | DIGIT+ '.';

terminal fragment EXPONENT_PART:
	('e' | 'E') ('+' | '-')? DIGIT+;

// lex.string
terminal STRING_LITERAL:
	ENC_PREFIX? '\"' SCHAR+ '\"';

terminal fragment ENC_PREFIX:
	'u8' | 'u' | 'U' | 'L';

terminal fragment SCHAR:
	!('\"' | '\\' | '\n') | ESCAPE_SEQUENCE | UNIVERSAL_CHARACTER_NAME;
	
// expr.prim.general
PrimaryExpression:
	Literal |
	'this' |
	'(' Expression ')' |
	IdExpression;

IdExpression:
	UnqualifiedId |
	QualifiedId;

UnqualifiedId:
	_UnqualifiedId |
	'~' (TypeName | DecltypeSpecifier);

_UnqualifiedId:
	SimpleTemplateIdOrId |
	'operator' (ConversionFunctionIdSuffix | (LiteralOperatorIdSuffix | OperatorFunctionIdSuffix) ('<' TemplateArgumentList? '>')?);

QualifiedId:
	NestedNameSpecifier 'template'? UnqualifiedId |
	'::' (NestedNameSpecifier 'template'? UnqualifiedId | _UnqualifiedId);

NestedNameSpecifier:
	(SimpleTemplateIdOrId | DecltypeSpecifier) '::' (('template' SimpleTemplateId | SimpleTemplateIdOrId) '::')*;

// expr.post
PostfixExpression:
	_PostfixExpression_Head (_PostfixExpression_Tail)*;

_PostfixExpression_Head:
	PrimaryExpression |
	SimpleTypeSpecifier ('(' ExpressionList? ')' | BracedInitList) |
	TypenameSpecifier ('(' ExpressionList? ')' | BracedInitList) |
	'dynamic_cast' '<' TypeId '>' '(' Expression ')' |
	'static_cast' '<' TypeId '>' '(' Expression ')' |
	'reinterpret_cast' '<' TypeId '>' '(' Expression ')' |
	'const_cast' '<' TypeId '>' '(' Expression ')' |
	'typeid' '(' (Expression | TypeId) ')';

_PostfixExpression_Tail:
	'[' Expression ']' |
	'[' BracedInitList? ']' |
	'(' ExpressionList? ')' |
	'.' 'template'? IdExpression |
	'->' 'template'? IdExpression |
	'++' |
	'--';

ExpressionList:
	InitializerList;

// expr.unary
UnaryExpression:
	PostfixExpression |
	'++' CastExpression |
	'--' CastExpression |
	UnaryOperator CastExpression |
	'sizeof' (UnaryExpression | '...' '(' ID ')' | '(' TypeId ')') |
	'alignof' '(' TypeId ')' |
	NoexceptExpression |
	NewExpression |
	DeleteExpression;

UnaryOperator:
	'*' |
	'&' |
	'+' |
	'-' |
	'!' |
	'~';

// expr.new
NewExpression:
	'::'? 'new' NewPlacement? ('(' TypeId ')' | NewTypeId) NewInitializer?;

NewPlacement:
	'(' ExpressionList ')';

NewTypeId:
	TypeSpecifier+ NewDeclarator?;

NewDeclarator:
	NoptrNewDeclarator;

NoptrNewDeclarator:
	'[' Expression ']' ('[' ConstantExpression ']')*;

NewInitializer:
	'[' ExpressionList? ']' | BracedInitList;

// expr.delete
DeleteExpression:
	'::'? 'delete' ('[' ']') CastExpression;

// expr.unary.noexcept
NoexceptExpression:
	'noexcept' '(' Expression ')';

// expr.cast
CastExpression:
	('(' TypeId ')')* UnaryExpression;

// expr.mptr.oper
PmExpression:
	CastExpression (('.*' | '->*') CastExpression)*;

// expr.mul
MultiplicativeExpression:
	PmExpression (('*' | '/' | '%') PmExpression)*;

// expr.add
AdditiveExpression:
	MultiplicativeExpression (('+' | '-') AdditiveExpression)*;

// expr.shift
ShiftExpression:
	AdditiveExpression (('<<' | '>>') AdditiveExpression)*;

// expr.rel
RelationalExpression:
	ShiftExpression (('>' | '<' | '<=' | '>=') ShiftExpression)*;

// expr.eq
EqualityExpression:
	RelationalExpression (('==' | '!=') EqualityExpression)*;

// expr.bit.and
AndExpression:
	EqualityExpression ('&' EqualityExpression)*;

// expr.xor
ExclusiveOrExpression:
	AndExpression ('^' AndExpression)*;

// expr.or
InclusiveOrExpression:
	ExclusiveOrExpression ('|' ExclusiveOrExpression)*;

// expr.log.and
LogicalAndExpression:
	InclusiveOrExpression ('&&' InclusiveOrExpression)*;

// expr.log.or
LogicalOrExpression:
	LogicalAndExpression ('||' LogicalAndExpression)*;

// expr.cond
ConditionalExpression:
	LogicalOrExpression '?' Expression ':' AssignmentExpression;

// expr.ass
AssignmentExpression:
	ConditionalExpression |
	LogicalOrExpression AssignmentOperator InitializerClause;

AssignmentOperator:
	'=' |
	'*=' |
	'/=' |
	'%=' |
	'+=' |
	'-=' |
	'>>=' |
	'<<=' |
	'&=' |
	'^=' |
	'|=';

// expr.comma
Expression:
	AssignmentExpression (',' AssignmentExpression)*;

// expr.const
ConstantExpression:
	ConditionalExpression;
	
// stmt.stmt
Statement:
	LabeledStatement |
	ExpressionStatement |
	CompoundStatement |
	SelectionStatement |
	IterationStatement |
	JumpStatement |
	DeclarationStatement |
	TryBlock;

// stmt.label
LabeledStatement:
	ID ':' Statement |
	'case' ConstantExpression ':' Statement |
	'default' ':' Statement;

// stmt.expr
ExpressionStatement:
	Expression ';';

// stmt.block
CompoundStatement:
	'{' Statement* '}';

// stmt.select
SelectionStatement:
	// 'if' '(' Condition ')' Statement (=> 'else' Statement)? |
	'switch' '(' Condition ')' Statement;

Condition:
	Expression |
	DeclarationSpecifier+ DeclaratorId ('=' InitializerClause | BracedInitList);

// stmt.iter
IterationStatement:
	'while' '(' Condition ')' Statement |
	'do' Statement 'while' '(' Expression ')' ';' |
	'for' '(' ForInitializationStatement Condition? ';' Expression? ')' Statement;

ForInitializationStatement:
	ExpressionStatement |
	SimpleDeclaration;

// stmt.jump
JumpStatement:
	'break' ';' |
	'continue' ';' |
	'return' (Expression | BracedInitList)? ';' |
	'goto' ID ';';

// stmt.dcl
DeclarationStatement:
	SimpleDeclaration |
	BlockDeclaration;

// dcl.dcl
Declaration:
	SimpleOrFunctionDeclaration |
	BlockDeclaration |
	TemplateDeclaration |
	ExplicitInstantiation |
	ExplicitSpecialization |
	LinkageSpecification |
	NamespaceDefinition;

BlockDeclaration:
	AsmDefinition |
	NamespaceAliasDefinition |
	AliasDeclarationOrUsingDeclarationOrDirective |
	StaticAssertDeclaration;

AliasDeclarationOrUsingDeclarationOrDirective:
	'using' (AliasDeclarationSuffix | UsingDeclarationSuffix | UsingDirectiveSuffix);

AliasDeclarationSuffix:
	ID '=' TypeId ';';

SimpleDeclaration:
	DeclarationSpecifier* SimpleDeclarationSuffix;

SimpleOrFunctionDeclaration:
	DeclarationSpecifier* (SimpleDeclarationSuffix | FunctionDeclarationSuffix);

SimpleDeclarationSuffix:
	InitDeclaratorList? ';';

FunctionDeclarationSuffix:
	FunctionDeclarator (FunctionBody | '=' 'default' ';' | '=' 'delete' ';');

StaticAssertDeclaration:
	'static_assert' '(' ConstantExpression ',' STRING_LITERAL ')' ';';

// dcl.spec
DeclarationSpecifier:
	StorageClassSpecifier |
	TypeSpecifier |
	FunctionSpecifier |
	'friend' |
	'typedef' |
	'constexpr';

// dcl.stc
StorageClassSpecifier:
	'register' |
	'static' |
	'thread_local' |
	'extern' |
	'mutable';

// dcl.fct.spec
FunctionSpecifier:
	'inline' |
	'virtual' |
	'explicit';

// dcl.type
TypeSpecifier:
	TrailingTypeSpecifier |
	ClassSpecifier |
	EnumSpecifier;

TrailingTypeSpecifier:
	SimpleTypeSpecifier |
	TypenameSpecifier |
	CvQualifier;

// dct.type.simple
SimpleTypeSpecifier:
	'::'? (TypeName | NestedNameSpecifier (TypeName | 'template' SimpleTemplateId)) |
	'char' |
	'char16_t' |
	'char32_t' |
	'wchar_t' |
	'bool' |
	'short' |
	'int' |
	'long' |
	'signed' |
	'unsigned' |
	'float' |
	'double' |
	'void' |
	'auto' |
	DecltypeSpecifier;

TypeName:
	SimpleTemplateIdOrId;

DecltypeSpecifier:
	'decltype' '(' Expression ')';

// dcl.enum
EnumName:
	ID;

EnumSpecifier:
	EnumHead '{' (EnumeratorList ','?)? '}';

EnumHead:
	EnumKey (ID? | NestedNameSpecifier ID) EnumBase?;

EnumKey:
	'enum' |
	'enum' 'class' |
	'enum' 'struct';
	
EnumBase:
	':' TypeSpecifier+;

EnumeratorList:
	EnumerationDefinition (',' EnumerationDefinition)*;

EnumeratorDefinition:
	Enumerator ('=' ConstantExpression)?;

Enumerator:
	EnumName;

// namespace.def
NamespaceName:
	ID;

NamespaceDefinition:
	'inline'? 'namespace' NamespaceName? '{' NamespaceBody '}';

NamespaceBody:
	Declaration*;

// namespace.alias
NamespaceAliasDefinition:
	'namespace' NamespaceName '=' QualifiedNamespaceSpecifier ';';

QualifiedNamespaceSpecifier:
	'::'? NestedNameSpecifier? NamespaceName;

// namespace.udecl
UsingDeclaration:
	'using' UsingDeclarationSuffix;

UsingDeclarationSuffix:
	('typename' '::'? NestedNameSpecifier | '::' NestedNameSpecifier? | NestedNameSpecifier) UnqualifiedId ';';

// namespace.udir
UsingDirective:
	'using' UsingDirectiveSuffix;

UsingDirectiveSuffix:
	'namespace' '::'? NestedNameSpecifier? NamespaceName ';';

// dcl.asm
AsmDefinition:
	'asm' '(' STRING_LITERAL ')' ';';

// dcl.link
LinkageSpecification:
	'extern' STRING_LITERAL (Declaration | '{' Declaration* '}');

// dcl.decl
InitDeclaratorList:
	InitDeclarator (',' InitDeclarator)*;

InitDeclarator:
	DeclaratorId Initializer?;

Declarator:
	NoptrDeclarator;
	
NoptrDeclarator:
	DeclaratorId ('[' ConstantExpression? ']')*;

ParametersAndQualifiers:
	'(' ParameterDeclarationClause? ')' ('const' | 'volatile')? ('&' | '&&')? ExceptionSpecification?;

DeclaratorId:
	'...'? IdExpression;

// dcl.name
TypeId:
	TypeSpecifier+;

// dcl.fct
ParameterDeclarationClause:
	'...'? |
	ParameterDeclarationList (','? '...')?;

ParameterDeclarationList:
	ParameterDeclaration (',' ParameterDeclaration)*;

ParameterDeclaration:
	DeclarationSpecifier+ (Declarator '='?)? InitializerClause;

// dcl.fct.def.general
FunctionDeclarator:
	DeclaratorId ParametersAndQualifiers;
	
FunctionBody:
	CtorInitializer? CompoundStatement |
	FunctionTryBlock;

// dcl.init
Initializer:
	BraceOrEqualInitializer |
	'(' ExpressionList ')';

BraceOrEqualInitializer:
	'=' InitializerClause |
	BracedInitList;

InitializerClause:
	AssignmentExpression |
	BracedInitList;

InitializerList:
	InitializerClause '...'? (',' InitializerClause '...'?)*;

BracedInitList:
	'{' (InitializerList ','?)? '}';

// class
ClassName:
	SimpleTemplateIdOrId;

ClassSpecifier:
	ClassHead '{' MemberSpecification? '}';

ClassHead:
	ClassKey (ClassHeadName ClassVirtualSpecifier*)? BaseClause?;

ClassHeadName:
	NestedNameSpecifier? ClassName;

ClassVirtualSpecifier:
	'final' |
	'explicit';

ClassKey:
	'class' |
	'struct' |
	'union';

// class.mem
MemberSpecification:
	(MemberDeclaration | AccessSpecifier ':') MemberSpecification?;

MemberDeclaration:
	MemberOrFunctionDeclaration |
	UsingDeclaration |
	StaticAssertDeclaration |
	TemplateDeclaration |
	AliasDeclaration;

MemberOrFunctionDeclaration:
	DeclarationSpecifier* (FunctionDeclarationSuffix | MemberDeclarationSuffix ';');

MemberDeclarationSuffix:
	MemberDeclaratorList?;

MemberDeclaratorList:
	MemberDeclarator (',' MemberDeclarator)*;

MemberDeclarator:
	Declarator VirtualSpecifier* (PureSpecifier | BraceOrEqualInitializer)?;

VirtualSpecifier:
	'override' |
	'final' |
	'new';

PureSpecifier:
	'=' '0';

// class.derived
BaseClause:
	':' BaseSpecifierList;

BaseSpecifierList:
	BaseSpecifier '...'? (',' BaseSpecifier '...'?)*;

BaseSpecifier:
	('virtual' AccessSpecifier? | AccessSpecifier 'virtual'?)? BaseTypeSpecifier;

ClassOrDecltype:
	'::'? NestedNameSpecifier? ClassName |
	DecltypeSpecifier;

BaseTypeSpecifier:
	ClassOrDecltype;

AccessSpecifier:
	'private' |
	'protected' |
	'public';

// class.base.init
ConversionFunctionId:
	'operator';

ConversionFunctionIdSuffix:
	ConversionTypeId;

ConversionTypeId:
	TypeSpecifier+;

// class.base.init
CtorInitializer:
	':' MemInitializerList;

MemInitializerList:
	MemInitializer '...'? (',' MemInitializer '...'?)*;
	
MemInitializer:
	MemInitializerId ('(' ExpressionList ')' | BracedInitList);

MemInitializerId:
	ClassOrDecltype | ID;

// over.oper
OperatorFunctionId:
	'operator' OperatorFunctionIdSuffix;

OperatorFunctionIdSuffix:
	OverloadableOperator ('<' TemplateArgumentList? '>')?;

OverloadableOperator:
	'new' |
	'delete' |
	'new' '[' ']' |
	'delete' '[' ']' |
	'+' |
	'-' |
	'*' |
	'/' |
	'%' |
	'^' |
	'&' |
	'|' |
	'~' |
	'!' |
	'=' |
	'<' |
	'>' |
	'+=' |
	'-=' |
	'*=' |
	'/=' |
	'%=' |
	'^=' |
	'&=' |
	'|=' |
	'<<' |
	'>>' |
	'>>=' |
	'<<=' |
	'==' |
	'!=' |
	'<=' |
	'>=' |
	'&&' |
	'||' |
	'++' |
	'--' |
	',' |
	'->*' |
	'->' |
	'()' |
	'[]';

LiteralOperatorId:
	'operator' LiteralOperatorIdSuffix;
	
LiteralOperatorIdSuffix:
	'\"\"' ID;

// temp
TemplateDeclaration:
	'template' '<' TemplateParameterList '>' Declaration;

TemplateParameterList:
	TemplateParameter (',' TemplateParameter)*;

// temp.param
TemplateParameter:
	TypeParameter | ParameterDeclaration;

TypeParameter:
	('class' | 'typename') ('...'? ID? | ID? '=' TypeId);
	'template' '<' TemplateParameterList '>' 'class' ('...'? ID? | ID? '=' IdExpression);

// temp.names
SimpleTemplateId:
	TemplateName '<' TemplateArgumentList '>';

TemplateId:
	SimpleTemplateId |
	'operator' (LiteralOperatorIdSuffix | OperatorFunctionIdSuffix) '<' TemplateArgumentList? '>';

TemplateName:
	Id;

TemplateArgumentList:
	TemplateArgument '...'? (',' TemplateArgument '...'?)*;

TemplateArgument:
	ConstantExpression |
	TypeId |
	IdExpression;

// temp.res
TypenameSpecifier:
	'typename' '::'? NestedNameSpecifier ('template' SimpleTemplateId | SimpleTemplateIdOrId);

SimpleTemplateIdOrId:
	ID ('<' TemplateArgumentList '>')?;

// temp.explicit
// temp.expl.spec
ExplicitInstantiationOrSpecialization:
	('extern' 'template' | 'template' ('<' '>')?) Declaration;

// except
TryBlock:
	'try' CompoundStatement Handler+;

FunctionTryBlock:
	'try' CtorInitializer? CompoundStatement Handler+;

Handler:
	'catch' '(' ExceptionDeclaration ')' CompoundStatement;

ExceptionDeclaration:
	TypeSpecifier+ Declarator? | 
	'...';
	
ThrowExpression:
	'throw' AssignmentExpression?;

// except.spec
ExceptionSpecification:
	DynamicExceptionSpecification |
	NoexceptSpecification;

DynamicExceptionSpecification:
	'throw' '(' TypeIdList? ')';

TypeIdList:
	TypeId '...'? (',' TypeId '...'?)*;

NoexceptSpecification:
	'noexcept' ('(' ConstantExpression ')')?;



