/**
 * generated by Xtext
 */
package org.xtext.example.mydsl.generator;

import com.google.common.base.Objects;
import com.google.common.collect.Iterables;
import java.util.ArrayList;
import java.util.List;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.common.util.TreeIterator;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.generator.IFileSystemAccess;
import org.eclipse.xtext.generator.IGenerator;
import org.eclipse.xtext.nodemodel.ICompositeNode;
import org.eclipse.xtext.nodemodel.INode;
import org.eclipse.xtext.nodemodel.util.NodeModelUtils;
import org.eclipse.xtext.xbase.lib.IteratorExtensions;
import org.xtext.example.mydsl.myDsl.Atomic;
import org.xtext.example.mydsl.myDsl.Body;
import org.xtext.example.mydsl.myDsl.BooleanhType;
import org.xtext.example.mydsl.myDsl.CaseNormal;
import org.xtext.example.mydsl.myDsl.Declaration;
import org.xtext.example.mydsl.myDsl.DefaultCase;
import org.xtext.example.mydsl.myDsl.FunctionChamada;
import org.xtext.example.mydsl.myDsl.FunctionDeclaration;
import org.xtext.example.mydsl.myDsl.FunctionType;
import org.xtext.example.mydsl.myDsl.IntType;
import org.xtext.example.mydsl.myDsl.NoPtrCases;
import org.xtext.example.mydsl.myDsl.NoPtrExpression;
import org.xtext.example.mydsl.myDsl.NoPtrMudanca;
import org.xtext.example.mydsl.myDsl.NoPtrSelect;
import org.xtext.example.mydsl.myDsl.NoPtrStatement;
import org.xtext.example.mydsl.myDsl.NoPtrTerminalExpression;
import org.xtext.example.mydsl.myDsl.Parameter;
import org.xtext.example.mydsl.myDsl.Return;
import org.xtext.example.mydsl.myDsl.ReturnExpr;
import org.xtext.example.mydsl.myDsl.StringhType;
import org.xtext.example.mydsl.myDsl.Type;
import org.xtext.example.mydsl.myDsl.VarDecl;
import org.xtext.example.mydsl.myDsl.Variable;
import org.xtext.example.mydsl.myDsl.impl.FunctionChamadaImpl;
import org.xtext.example.mydsl.myDsl.impl.NoPtrExpressionImpl;
import org.xtext.example.mydsl.myDsl.impl.NoPtrMudancaImpl;
import org.xtext.example.mydsl.myDsl.impl.NoPtrSelectImpl;
import org.xtext.example.mydsl.myDsl.impl.ReturnImpl;
import org.xtext.example.mydsl.myDsl.impl.VarDeclImpl;
import org.xtext.example.mydsl.myDsl.simple_type_specifier;

/**
 * Generates code from your model files on save.
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#TutorialCodeGeneration
 */
@SuppressWarnings("all")
public class MyDslGenerator implements IGenerator {
  private int regCounter = 0;
  
  private int switch_n = 0;
  
  public void doGenerate(final Resource resource, final IFileSystemAccess fsa) {
    String code = "";
    this.regCounter = 0;
    this.switch_n = 0;
    TreeIterator<EObject> _allContents = resource.getAllContents();
    Iterable<EObject> _iterable = IteratorExtensions.<EObject>toIterable(_allContents);
    Iterable<Body> _filter = Iterables.<Body>filter(_iterable, Body.class);
    for (final Body declaration : _filter) {
      EList<Declaration> _declarations = declaration.getDeclarations();
      for (final Declaration dec : _declarations) {
        VarDecl _variaveis = dec.getVariaveis();
        boolean _notEquals = (!Objects.equal(_variaveis, null));
        if (_notEquals) {
          VarDecl _variaveis_1 = dec.getVariaveis();
          VarDeclImpl _cast = VarDeclImpl.class.cast(_variaveis_1);
          String _compile = this.compile(_cast);
          String _plus = (code + _compile);
          code = _plus;
          this.regCounter = (this.regCounter + 1);
        } else {
          FunctionChamada _chamada = dec.getChamada();
          boolean _notEquals_1 = (!Objects.equal(_chamada, null));
          if (_notEquals_1) {
            FunctionChamada _chamada_1 = dec.getChamada();
            FunctionChamadaImpl _cast_1 = FunctionChamadaImpl.class.cast(_chamada_1);
            String _compile_1 = this.compile(_cast_1);
            String _plus_1 = (code + _compile_1);
            code = _plus_1;
            this.regCounter = (this.regCounter + 1);
          }
        }
      }
    }
    TreeIterator<EObject> _allContents_1 = resource.getAllContents();
    Iterable<EObject> _iterable_1 = IteratorExtensions.<EObject>toIterable(_allContents_1);
    Iterable<FunctionDeclaration> _filter_1 = Iterables.<FunctionDeclaration>filter(_iterable_1, FunctionDeclaration.class);
    for (final FunctionDeclaration declaration_1 : _filter_1) {
      {
        String _compile_2 = this.compile(declaration_1);
        String _plus_2 = (code + _compile_2);
        code = _plus_2;
        this.regCounter = (this.regCounter + 1);
      }
    }
    fsa.generateFile("gen.asm", code);
  }
  
  public String compile(final VarDecl variavel) {
    String ret = "";
    NoPtrExpression _expr = variavel.getExpr();
    boolean _equals = Objects.equal(_expr, null);
    if (_equals) {
      ret = (("LD R" + Integer.valueOf(this.regCounter)) + ", #");
      Type _type = variavel.getType();
      simple_type_specifier _sts = _type.getSts();
      String _name = _sts.getName();
      boolean _equals_1 = Objects.equal(_name, "int");
      if (_equals_1) {
        ret = (ret + "0");
      } else {
        Type _type_1 = variavel.getType();
        simple_type_specifier _sts_1 = _type_1.getSts();
        String _name_1 = _sts_1.getName();
        boolean _equals_2 = Objects.equal(_name_1, "string");
        if (_equals_2) {
          ret = (ret + "\"\"");
        } else {
          Type _type_2 = variavel.getType();
          simple_type_specifier _sts_2 = _type_2.getSts();
          String _name_2 = _sts_2.getName();
          boolean _equals_3 = Objects.equal(_name_2, "bool");
          if (_equals_3) {
            ret = (ret + "false");
          } else {
            ret = (ret + "null");
          }
        }
      }
    }
    StringConcatenation _builder = new StringConcatenation();
    _builder.append(ret, "");
    _builder.newLineIfNotEmpty();
    NoPtrExpression _expr_1 = variavel.getExpr();
    String _compile = this.compile(_expr_1);
    _builder.append(_compile, "");
    _builder.newLineIfNotEmpty();
    _builder.append("ST ");
    String _name_3 = variavel.getName();
    _builder.append(_name_3, "");
    _builder.append(", R");
    _builder.append(this.regCounter, "");
    _builder.newLineIfNotEmpty();
    return _builder.toString();
  }
  
  public String compile(final Parameter variavel) {
    String ret = "";
    NoPtrExpression _expr = variavel.getExpr();
    boolean _equals = Objects.equal(_expr, null);
    if (_equals) {
      ret = (("LD R" + Integer.valueOf(this.regCounter)) + ", #");
      Type _type = variavel.getType();
      simple_type_specifier _sts = _type.getSts();
      String _name = _sts.getName();
      String _plus = ("Type GEN: " + _name);
      System.out.println(_plus);
      Type _type_1 = variavel.getType();
      simple_type_specifier _sts_1 = _type_1.getSts();
      String _name_1 = _sts_1.getName();
      boolean _equals_1 = Objects.equal(_name_1, "int");
      if (_equals_1) {
        ret = (ret + "0");
      } else {
        Type _type_2 = variavel.getType();
        simple_type_specifier _sts_2 = _type_2.getSts();
        String _name_2 = _sts_2.getName();
        boolean _equals_2 = Objects.equal(_name_2, "string");
        if (_equals_2) {
          ret = (ret + "\"\"");
        } else {
          Type _type_3 = variavel.getType();
          simple_type_specifier _sts_3 = _type_3.getSts();
          String _name_3 = _sts_3.getName();
          boolean _equals_3 = Objects.equal(_name_3, "bool");
          if (_equals_3) {
            ret = (ret + "false");
          } else {
            ret = (ret + "null");
          }
        }
      }
    }
    StringConcatenation _builder = new StringConcatenation();
    _builder.append(ret, "");
    _builder.newLineIfNotEmpty();
    NoPtrExpression _expr_1 = variavel.getExpr();
    String _compile = this.compile(_expr_1);
    _builder.append(_compile, "");
    _builder.newLineIfNotEmpty();
    _builder.append("ST ");
    String _name_4 = variavel.getName();
    _builder.append(_name_4, "");
    _builder.append(", R");
    _builder.append(this.regCounter, "");
    return _builder.toString();
  }
  
  public String compile(final IntType tipo) {
    String valor = "0";
    boolean _equals = Objects.equal(tipo, null);
    if (_equals) {
      valor = "0";
    } else {
      int _value = tipo.getValue();
      String _string = Integer.valueOf(_value).toString();
      valor = _string;
    }
    return ((("LD R" + Integer.valueOf(this.regCounter)) + ", #") + valor);
  }
  
  public String compile(final BooleanhType tipo) {
    String valor = "false";
    boolean _equals = Objects.equal(tipo, null);
    if (_equals) {
      valor = "false";
    } else {
      String _value = tipo.getValue();
      String _string = _value.toString();
      valor = _string;
    }
    return ((("LD R" + Integer.valueOf(this.regCounter)) + ", #") + valor);
  }
  
  public String compile(final StringhType tipo) {
    String valor = "\"\"";
    boolean _equals = Objects.equal(tipo, null);
    if (_equals) {
      valor = "\"\"";
    } else {
      String _value = tipo.getValue();
      String _plus = ("\"" + _value);
      String _plus_1 = (_plus + "\"");
      valor = _plus_1;
    }
    return ((("LD R" + Integer.valueOf(this.regCounter)) + ", #") + valor);
  }
  
  public String compile(final Variable expr) {
    ReturnExpr _expr = expr.getExpr();
    boolean _equals = Objects.equal(_expr, null);
    if (_equals) {
      String _name = expr.getName();
      return ((("LD R" + Integer.valueOf(this.regCounter)) + ", #") + _name);
    } else {
      StringConcatenation _builder = new StringConcatenation();
      ReturnExpr _expr_1 = expr.getExpr();
      String _compile = this.compile(_expr_1);
      _builder.append(_compile, "");
      _builder.newLineIfNotEmpty();
      _builder.append("ST ");
      String _name_1 = expr.getName();
      _builder.append(_name_1, "");
      _builder.append(", R");
      _builder.append(this.regCounter, "");
      _builder.newLineIfNotEmpty();
      _builder.append("LD R");
      _builder.append(this.regCounter, "");
      _builder.append(", ");
      String _name_2 = expr.getName();
      _builder.append(_name_2, "");
      _builder.newLineIfNotEmpty();
      return _builder.toString();
    }
  }
  
  public String compile(final ReturnExpr expr) {
    if ((expr instanceof BooleanhType)) {
      BooleanhType _cast = BooleanhType.class.cast(expr);
      return this.compile(_cast);
    } else {
      if ((expr instanceof IntType)) {
        IntType _cast_1 = IntType.class.cast(expr);
        return this.compile(_cast_1);
      } else {
        if ((expr instanceof StringhType)) {
          StringhType _cast_2 = StringhType.class.cast(expr);
          return this.compile(_cast_2);
        } else {
          if ((expr instanceof Variable)) {
            Variable _cast_3 = Variable.class.cast(expr);
            return this.compile(_cast_3);
          } else {
            if ((expr instanceof FunctionType)) {
              FunctionChamada _call = ((FunctionType)expr).getCall();
              return this.compile(_call);
            }
          }
        }
      }
    }
    boolean _equals = Objects.equal(expr, null);
    if (_equals) {
    }
    return "";
  }
  
  public String compile(final NoPtrMudanca mud) {
    NoPtrExpression _expr = mud.getExpr();
    boolean _notEquals = (!Objects.equal(_expr, null));
    if (_notEquals) {
      StringConcatenation _builder = new StringConcatenation();
      NoPtrExpression _expr_1 = mud.getExpr();
      String _compile = this.compile(_expr_1);
      _builder.append(_compile, "");
      _builder.newLineIfNotEmpty();
      _builder.append("ST ");
      String _name = mud.getName();
      _builder.append(_name, "");
      _builder.append(", R");
      _builder.append(this.regCounter, "");
      _builder.newLineIfNotEmpty();
      return _builder.toString();
    } else {
      return "";
    }
  }
  
  public String compile(final FunctionChamada funcao) {
    String ret = "";
    EList<ReturnExpr> _params = funcao.getParams();
    for (final ReturnExpr symb : _params) {
      {
        String _compile = this.compile(symb);
        String _plus = ((ret + "\n") + _compile);
        String _plus_1 = (_plus + "\nPUSH R");
        String _plus_2 = (_plus_1 + Integer.valueOf(this.regCounter));
        ret = _plus_2;
        this.regCounter = (this.regCounter + 1);
      }
    }
    StringConcatenation _builder = new StringConcatenation();
    _builder.append(ret, "");
    _builder.newLineIfNotEmpty();
    _builder.append("CALL ");
    String _name = funcao.getName();
    _builder.append(_name, "");
    _builder.newLineIfNotEmpty();
    _builder.append("LD R");
    _builder.append(this.regCounter, "");
    _builder.append(", EAX");
    _builder.newLineIfNotEmpty();
    return _builder.toString();
  }
  
  public CharSequence compile(final NoPtrCases symb, final int valor) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("SWITCH_LABEL_");
    String _string = Integer.valueOf(this.switch_n).toString();
    _builder.append(_string, "");
    _builder.append("_");
    String _string_1 = Integer.valueOf(valor).toString();
    _builder.append(_string_1, "");
    _builder.append(":");
    _builder.newLineIfNotEmpty();
    NoPtrStatement _v = symb.getV();
    String _compile = this.compile(_v);
    _builder.append(_compile, "");
    _builder.newLineIfNotEmpty();
    _builder.append("GOTO BEYOND_SWITCH_");
    String _string_2 = Integer.valueOf(this.switch_n).toString();
    _builder.append(_string_2, "");
    return _builder;
  }
  
  public String compile(final NoPtrSelect switche) {
    String _string = Integer.valueOf(this.switch_n).toString();
    String _plus = ("SWITCH_START_" + _string);
    String switch_rule = (_plus + ":");
    NoPtrExpression _expr = switche.getExpr();
    String expres = this.compile(_expr);
    int lastReg = this.regCounter;
    this.regCounter = (this.regCounter + 1);
    switch_rule = ((switch_rule + "\n") + expres);
    String _string_1 = Integer.valueOf(this.switch_n).toString();
    String up_part = (("GOTO " + "SWITCH_START_") + _string_1);
    int valor = 0;
    EList<NoPtrCases> _cases = switche.getCases();
    for (final NoPtrCases symb : _cases) {
      {
        CharSequence _compile = this.compile(symb, valor);
        String _plus_1 = ((up_part + "\n") + _compile);
        up_part = _plus_1;
        valor = (valor + 1);
      }
    }
    this.regCounter = (this.regCounter + 1);
    valor = 0;
    EList<NoPtrCases> _cases_1 = switche.getCases();
    for (final NoPtrCases symb_1 : _cases_1) {
      {
        if ((symb_1 instanceof DefaultCase)) {
          String _string_2 = Integer.valueOf(this.switch_n).toString();
          String _plus_1 = (((switch_rule + "\n") + "GOTO SWITCH_LABEL_") + _string_2);
          String _plus_2 = (_plus_1 + "_");
          String _string_3 = Integer.valueOf(valor).toString();
          String _plus_3 = (_plus_2 + _string_3);
          switch_rule = _plus_3;
        } else {
          if ((symb_1 instanceof CaseNormal)) {
            NoPtrExpression _expr_1 = ((CaseNormal)symb_1).getExpr();
            String _compile = this.compile(_expr_1);
            String _plus_4 = ((switch_rule + "\n") + _compile);
            switch_rule = _plus_4;
            String _string_4 = Integer.valueOf(this.regCounter).toString();
            String _plus_5 = (((switch_rule + "\n") + "CMP R") + _string_4);
            String _plus_6 = (_plus_5 + ", R");
            String _string_5 = Integer.valueOf(this.regCounter).toString();
            String _plus_7 = (_plus_6 + _string_5);
            String _plus_8 = (_plus_7 + ", R");
            String _string_6 = Integer.valueOf(lastReg).toString();
            String _plus_9 = (_plus_8 + _string_6);
            switch_rule = _plus_9;
            String _string_7 = Integer.valueOf(this.regCounter).toString();
            String _plus_10 = (((switch_rule + "\n") + "Bcond R") + _string_7);
            String _plus_11 = (_plus_10 + ", SWITCH_LABEL_");
            String _string_8 = Integer.valueOf(this.switch_n).toString();
            String _plus_12 = (_plus_11 + _string_8);
            String _plus_13 = (_plus_12 + "_");
            String _string_9 = Integer.valueOf(valor).toString();
            String _plus_14 = (_plus_13 + _string_9);
            switch_rule = _plus_14;
          }
        }
        valor = (valor + 1);
      }
    }
    this.switch_n = (this.switch_n + 1);
    StringConcatenation _builder = new StringConcatenation();
    _builder.append(up_part, "");
    _builder.newLineIfNotEmpty();
    _builder.append(switch_rule, "");
    _builder.newLineIfNotEmpty();
    _builder.newLine();
    _builder.append("BEYOND_SWITCH_");
    String _string_2 = Integer.valueOf((this.switch_n - 1)).toString();
    _builder.append(_string_2, "");
    _builder.append(":");
    _builder.newLineIfNotEmpty();
    return _builder.toString();
  }
  
  private INode node;
  
  private INode node2;
  
  private List<EObject> test;
  
  public List<EObject> sortObjects(final EList<EObject> lista) {
    int i = 0;
    ArrayList<EObject> _arrayList = new ArrayList<EObject>();
    this.test = _arrayList;
    for (final EObject obj : lista) {
      this.test.add(obj);
    }
    int _size = lista.size();
    boolean _lessThan = (i < _size);
    boolean _while = _lessThan;
    while (_while) {
      {
        int j = (i - 1);
        EObject _get = this.test.get(i);
        ICompositeNode _node = NodeModelUtils.getNode(_get);
        this.node = _node;
        boolean _while_1 = (j >= 0);
        while (_while_1) {
          {
            EObject _get_1 = this.test.get(j);
            ICompositeNode _node_1 = NodeModelUtils.getNode(_get_1);
            this.node2 = _node_1;
            int _startLine = this.node2.getStartLine();
            int _startLine_1 = this.node.getStartLine();
            boolean _greaterThan = (_startLine > _startLine_1);
            if (_greaterThan) {
              EObject obj_1 = this.test.get((j + 1));
              EObject _get_2 = this.test.get(j);
              this.test.set((j + 1), _get_2);
              this.test.set(j, obj_1);
            }
            j = (j - 1);
          }
          _while_1 = (j >= 0);
        }
        i = (i + 1);
      }
      int _size_1 = lista.size();
      boolean _lessThan_1 = (i < _size_1);
      _while = _lessThan_1;
    }
    return this.test;
  }
  
  public String compile(final NoPtrStatement statement) {
    StringConcatenation _builder = new StringConcatenation();
    {
      EList<EObject> _eContents = statement.eContents();
      List<EObject> _sortObjects = this.sortObjects(_eContents);
      for(final EObject decl : _sortObjects) {
        {
          if ((decl instanceof VarDecl)) {
            VarDeclImpl _cast = VarDeclImpl.class.cast(decl);
            String _compile = this.compile(_cast);
            _builder.append(_compile, "");
            _builder.newLineIfNotEmpty();
          } else {
            if ((decl instanceof NoPtrMudanca)) {
              NoPtrMudancaImpl _cast_1 = NoPtrMudancaImpl.class.cast(decl);
              String _compile_1 = this.compile(_cast_1);
              _builder.append(_compile_1, "");
              _builder.newLineIfNotEmpty();
            } else {
              if ((decl instanceof Return)) {
                ReturnImpl _cast_2 = ReturnImpl.class.cast(decl);
                String _compile_2 = this.compile(_cast_2);
                _builder.append(_compile_2, "");
                _builder.newLineIfNotEmpty();
              } else {
                if ((decl instanceof FunctionChamada)) {
                  FunctionChamadaImpl _cast_3 = FunctionChamadaImpl.class.cast(decl);
                  String _compile_3 = this.compile(_cast_3);
                  _builder.append(_compile_3, "");
                  _builder.newLineIfNotEmpty();
                } else {
                  if ((decl instanceof NoPtrSelect)) {
                    NoPtrSelectImpl _cast_4 = NoPtrSelectImpl.class.cast(decl);
                    String _compile_4 = this.compile(_cast_4);
                    _builder.append(_compile_4, "");
                    _builder.newLineIfNotEmpty();
                  } else {
                    if ((decl instanceof NoPtrExpression)) {
                      NoPtrExpressionImpl _cast_5 = NoPtrExpressionImpl.class.cast(decl);
                      String _compile_5 = this.compile(_cast_5);
                      _builder.append(_compile_5, "");
                      _builder.newLineIfNotEmpty();
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    return _builder.toString();
  }
  
  public String compile(final NoPtrTerminalExpression expr) {
    if ((expr instanceof Atomic)) {
      ReturnExpr _atomic = ((Atomic)expr).getAtomic();
      ReturnExpr _cast = ReturnExpr.class.cast(_atomic);
      return this.compile(_cast);
    }
    NoPtrExpression _inside = expr.getInside();
    return this.compile(_inside);
  }
  
  public String compile(final NoPtrExpression expr) {
    boolean _equals = Objects.equal(expr, null);
    if (_equals) {
      return "";
    } else {
      NoPtrTerminalExpression _left = expr.getLeft();
      String left = this.compile(_left);
      int reg = this.regCounter;
      String ret = "";
      String _op = expr.getOp();
      boolean _notEquals = (!Objects.equal(_op, null));
      if (_notEquals) {
        this.regCounter = (this.regCounter + 1);
        NoPtrTerminalExpression _right = expr.getRight();
        String right = this.compile(_right);
        String _op_1 = expr.getOp();
        boolean _equals_1 = Objects.equal(_op_1, "&&");
        if (_equals_1) {
          ret = ((((("AND R" + Integer.valueOf(this.regCounter)) + ", R") + Integer.valueOf(reg)) + ", R") + Integer.valueOf(this.regCounter));
        } else {
          String _op_2 = expr.getOp();
          boolean _equals_2 = Objects.equal(_op_2, "||");
          if (_equals_2) {
            ret = ((((("OR R" + Integer.valueOf(this.regCounter)) + ", R") + Integer.valueOf(reg)) + ", R") + Integer.valueOf(this.regCounter));
          } else {
            String _op_3 = expr.getOp();
            boolean _equals_3 = Objects.equal(_op_3, "==");
            if (_equals_3) {
              ret = ((((("CMP R" + Integer.valueOf(this.regCounter)) + ", R") + Integer.valueOf(reg)) + ", R") + Integer.valueOf(this.regCounter));
            } else {
              String _op_4 = expr.getOp();
              boolean _equals_4 = Objects.equal(_op_4, "!=");
              if (_equals_4) {
                ret = ((((("CMP R" + Integer.valueOf(this.regCounter)) + ", R") + Integer.valueOf(reg)) + ", R") + Integer.valueOf(this.regCounter));
                ret = ((((ret + "\nNOT R") + Integer.valueOf(this.regCounter)) + ", R") + Integer.valueOf(this.regCounter));
              }
            }
          }
        }
        ret = ((right + "\n") + ret);
      }
      StringConcatenation _builder = new StringConcatenation();
      _builder.append(left, "");
      _builder.newLineIfNotEmpty();
      _builder.append(ret, "");
      _builder.newLineIfNotEmpty();
      return _builder.toString();
    }
  }
  
  public String compile(final Return ret) {
    String antigo = "";
    NoPtrExpression _rettype = ret.getRettype();
    boolean _notEquals = (!Objects.equal(_rettype, null));
    if (_notEquals) {
      StringConcatenation _builder = new StringConcatenation();
      NoPtrExpression _rettype_1 = ret.getRettype();
      String _compile = this.compile(_rettype_1);
      _builder.append(_compile, "");
      _builder.newLineIfNotEmpty();
      _builder.append("LD RET, R");
      _builder.append(this.regCounter, "");
      antigo = _builder.toString();
    }
    StringConcatenation _builder_1 = new StringConcatenation();
    _builder_1.append(antigo, "");
    _builder_1.newLineIfNotEmpty();
    _builder_1.append("RETURN");
    _builder_1.newLine();
    return _builder_1.toString();
  }
  
  public String getNameFunction(final FunctionDeclaration funcao) {
    String _name = funcao.getName();
    String nome = (_name + "(");
    int ok = 0;
    EList<Parameter> _params = funcao.getParams();
    for (final Parameter symb : _params) {
      {
        if ((ok == 1)) {
          nome = (nome + ",");
        }
        ok = 1;
        Type _type = symb.getType();
        simple_type_specifier _sts = _type.getSts();
        String _name_1 = _sts.getName();
        String _plus = (nome + _name_1);
        nome = _plus;
      }
    }
    nome = (nome + ")");
    return nome;
  }
  
  public String compile(final FunctionDeclaration functionDecl) {
    StringConcatenation _builder = new StringConcatenation();
    String _nameFunction = this.getNameFunction(functionDecl);
    _builder.append(_nameFunction, "");
    _builder.append(":");
    _builder.newLineIfNotEmpty();
    {
      EList<Parameter> _params = functionDecl.getParams();
      for(final Parameter decl : _params) {
        String _compile = this.compile(decl);
        _builder.append(_compile, "");
        _builder.newLineIfNotEmpty();
      }
    }
    NoPtrStatement _escopo = functionDecl.getEscopo();
    String _compile_1 = this.compile(_escopo);
    _builder.append(_compile_1, "");
    _builder.newLineIfNotEmpty();
    _builder.append("halt");
    _builder.newLine();
    return _builder.toString();
  }
}
