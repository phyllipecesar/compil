/**
 * generated by Xtext
 */
package org.xtext.example.mydsl.validation;

import com.google.common.base.Objects;
import java.util.HashSet;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.Functions.Function0;
import org.xtext.example.mydsl.myDsl.Body;
import org.xtext.example.mydsl.myDsl.Declaration;
import org.xtext.example.mydsl.myDsl.FunctionDeclaration;
import org.xtext.example.mydsl.myDsl.Parameter;
import org.xtext.example.mydsl.myDsl.Return;
import org.xtext.example.mydsl.myDsl.Type;
import org.xtext.example.mydsl.myDsl.simple_type_specifier;
import org.xtext.example.mydsl.validation.AbstractMyDslValidator;

/**
 * Custom validation rules.
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
@SuppressWarnings("all")
public class MyDslValidator extends AbstractMyDslValidator {
  private HashSet<String> hash = new Function0<HashSet<String>>() {
    public HashSet<String> apply() {
      HashSet<String> _hashSet = new HashSet<String>();
      return _hashSet;
    }
  }.apply();
  
  @Check
  public void checkParamsFunction(final FunctionDeclaration funcao) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method variavel is undefined for the type MyDslValidator"
      + "\nvariaveis cannot be resolved");
  }
  
  private String row;
  
  private int ok;
  
  @Check
  public void checkFunctionAlreadyExists(final Body b) {
    this.hash.clear();
    EList<Declaration> _declarations = b.getDeclarations();
    for (final Declaration symbol : _declarations) {
      FunctionDeclaration _funcao = symbol.getFuncao();
      String _name = _funcao.getName();
      boolean _notEquals = (!Objects.equal(_name, "null"));
      if (_notEquals) {
        FunctionDeclaration _funcao_1 = symbol.getFuncao();
        String _name_1 = _funcao_1.getName();
        String _plus = (_name_1 + "(");
        this.row = _plus;
        this.ok = 0;
        FunctionDeclaration _funcao_2 = symbol.getFuncao();
        EList<Parameter> _params = _funcao_2.getParams();
        for (final Parameter symb : _params) {
          {
            if ((this.ok == 1)) {
              this.row = (this.row + ",");
            }
            this.ok = 1;
            Type _type = symb.getType();
            simple_type_specifier _sts = _type.getSts();
            String _name_2 = _sts.getName();
            String _plus_1 = (this.row + _name_2);
            this.row = _plus_1;
          }
        }
        this.row = (this.row + ")");
        boolean _contains = this.hash.contains(this.row);
        if (_contains) {
          FunctionDeclaration _funcao_3 = symbol.getFuncao();
          this.error((("Function \'" + this.row) + "\' already exists"), _funcao_3, null, (-1));
        }
        this.hash.add(this.row);
      }
    }
  }
  
  @Check
  public void checkReturnOnlyOnFunction(final Return r) {
    EObject _eContainer = r.eContainer();
    boolean _equals = Objects.equal(_eContainer, null);
    if (_equals) {
      this.error("return can only be used inside of functions", r, null, (-1));
    }
    EObject _eContainer_1 = r.eContainer();
    Class<? extends EObject> _class = _eContainer_1.getClass();
    System.out.println(_class);
    EObject _eContainer_2 = r.eContainer();
    EObject _eContainer_3 = _eContainer_2.eContainer();
    boolean _equals_1 = Objects.equal(_eContainer_3, null);
    if (_equals_1) {
      this.error("return can only be used inside of functions", r, null, (-1));
    }
    EObject _eContainer_4 = r.eContainer();
    EObject _eContainer_5 = _eContainer_4.eContainer();
    EObject _eContainer_6 = _eContainer_5.eContainer();
    boolean _equals_2 = Objects.equal(_eContainer_6, null);
    if (_equals_2) {
      this.error("return can only be used inside of functions", r, null, (-1));
    }
    EObject _eContainer_7 = r.eContainer();
    EObject _eContainer_8 = _eContainer_7.eContainer();
    EObject _eContainer_9 = _eContainer_8.eContainer();
    EObject _eContainer_10 = _eContainer_9.eContainer();
    Class<? extends EObject> _class_1 = _eContainer_10.getClass();
    boolean _notEquals = (!Objects.equal(_class_1, FunctionDeclaration.class));
    if (_notEquals) {
      this.error("return can only be used inside of functions", r, null, (-1));
    }
  }
  
  @Check
  public void checkVariableAlreadyExists(final /* statement */Object st) {
    throw new Error("Unresolved compilation problems:"
      + "\nvariavel cannot be resolved"
      + "\nvariaveis cannot be resolved");
  }
}
