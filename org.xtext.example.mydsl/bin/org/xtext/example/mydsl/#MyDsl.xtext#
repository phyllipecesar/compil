grammar org.xtext.example.mydsl.MyDsl with org.eclipse.xtext.common.Terminals

generate myDsl "http://www.xtext.org/example/mydsl/MyDsl"

/*
 * SO FAR
 * 
 * LEX.PPNUMBER     [OK]
 * LEX.NAME         [OK]
 * LEX.KEY          [OK]
 * LEX.OPERATORS    [OK]
 * Lex.Token        [OK]
 *
 */

Model:
	preprocessing_file
	elements+=statement;


VarDecl:
	{VarDecl} type=Type name=IDENTIFIER
;

Type:
	simple_type_specifier
;
simple_type_specifier:
	{IntType}"int" |
	{BoolType} "bool";

new_line:
	'\n' | '\r\n'
;
preprocessing_file:
	group?
;

group:
	group_part+
;

group_part:
	// pp_tokens? new_line |
	if_action |
	control_line;

if_action:
	if_group elif_groups? else_group? endif_line
;
if_group:
	'#if' constant_expression new_line group?|
	'#ifdef' IDENTIFIER new_line group?|
	'#ifndef' IDENTIFIER new_line group?
;
elif_groups:
	elif_group+;
	
elif_group:
  '#elif' constant_expression new_line group?;


//// A.5
statement:
//	expression_statement|
//	compound_statement|
//	jump_statement|
	{statement} variavel = declaration_statement
//	selection_statement
	;
//iteration_statement:
//	'while (' condition ')' statement|
//	'do' statement 'while ('expression ');'|
//	'for ( 'for_init_statement condition? ';' expression? ')' statement;
//
//for_init_statement:
//	expression_statement|simple_declaration;
//
simple_declaration:
	variavel = VarDecl ';' new_line
;
//expression_statement:
//	expression?
//;
//compound_statement:
//	'{' statement_seq? '}';
//	
//statement_seq:
//	(statement)+;
//selection_statement:
//	'if (' condition ')' statement |
//	'if (' condition ')' statement |
//	'switch (' condition ')' statement;
//
//
//// TODO(condition')
//condition:
//	expression
//;
//jump_statement:
//	'break;'|
//	'continue;'|
//	'return' expression?';'|
//	'goto' IDENTIFIER';'
//;
declaration_statement:
	(variaveis += block_declaration)+
;
//
//// TODO
block_declaration:
	{block_declaration} variavel = simple_declaration
;

constant_expression:
	conditional_expression;
	
conditional_expression:
//	logical_or_expression |
	logical_or_expression ('?' expression ':' assignment_expression)?;

logical_or_expression:
	logical_and_expression ('||' logical_and_expression )*;

logical_and_expression:
	inclusive_or_expression ('&&' inclusive_or_expression)*;

inclusive_or_expression:
	exclusive_or_expression ('|' exclusive_or_expression)*;

exclusive_or_expression:
	and_expression ('^' and_expression)*;

and_expression:
	equality_expression ('&' equality_expression)*;

equality_expression:
	relational_expression (('==' | '!=') relational_expression)*;

relational_expression:
	shift_expression (('<' | '>' | '<=' | '>=') shift_expression)*;

shift_expression:
	additive_expression (('<<' | '>>') additive_expression)*;

additive_expression:
	multiplicative_expression (SIGN multiplicative_expression)*;

multiplicative_expression:
	pm_expression (('*' | '/' | '%') pm_expression)*;

pm_expression:
	cast_expression (('.*' | '->*') cast_expression)*;

cast_expression:
	('(' IDENTIFIER ')')* unary_expression;
	//TODO replace IDENTIFIER with type_id, I guess

unary_expression:
	('sizeof')* postfix_expression |
	('sizeof')* ('++' | '--' | unary_operator ) cast_expression |
	'sizeof' '(' IDENTIFIER ')' |//TODO replace IDENTIFIER with type_id
	('sizeof')* new_expression |
	('sizeof')* delete_expression;

postfix_expression:
	primary_expression ('[' expression ']' |
						'(' expression_list? ')' |
						'.' 'template'? (IDENTIFIER | pseudo_destructor_name) | //TODO replace IDENTIFIER with id_expression
						'->' 'template'? (IDENTIFIER | pseudo_destructor_name) | //TODO replace IDENTIFIER with id_expression
						'++' |
						'--')*;

primary_expression:
	'==primary==';

pseudo_destructor_name:
	'::'? nested_name_specifier? type_name '::' '~' type_name |
	'::'? nested_name_specifier 'template' template_id '::' '~' type_name;

nested_name_specifier:
	class_or_namespace_name '::' nested_name_specifier? |
	class_or_namespace_name '::' nested_name_specifier;
	;

class_or_namespace_name:
	class_name | namespace_name;

class_name:
	IDENTIFIER | template_id;

namespace_name:
	'==namespace==';

type_name:
	'==type_name==';

template_id:
	IDENTIFIER '<' template_argument_list '>' 'class';

template_argument_list:
	template_argument (',' template_argument)*;

template_argument:
	assignment_expression |
	IDENTIFIER | //TODO replace with type_id
	id_expression;

id_expression:
	unqualified_id |
	qualified_id;

unqualified_id:
	IDENTIFIER |
	operator_function_id |
	conversion_function_id |
	'~' class_name |
	template_id;

operator_function_id:
	'operator' operator;

operator:
	'new' | 'delete' | 'new[]' | 'delete[]' | '+' | '-' | '*' | '/' | '%' | '^' | '&' | '|' | '~' | '!' | '=' | '<' | '>' |
	'+=' | '-=' | '*=' | '/=' | '%=' | '^=' | '&=' | '|=' | '<<' | '>>' | '<<=' | '>>=' | '==' | '!=' | '<=' | '>=' | '&&' |
	'||' | '++' | '--' | ',' | '->*' | '->' | '()' | '[]';

conversion_function_id:
	'operator' conversion_type_id;

conversion_type_id:
	type_specifier_seq conversion_declarator?;

conversion_declarator:
	'==conversion==';

type_specifier_seq:
	type_specifier+;

type_specifier:
	'==type_specifier==';

qualified_id:
	'==qualified==';

new_expression:
	'==new==';

delete_expression:
	'==delete==';

unary_operator:
	('*' | '&' | '+' | '-' | '!' | '~');

expression_list:
	assignment_expression (',' assignment_expression)*;

expression:
	'==expression==';

assignment_expression:
	'==assignment==';

terminal HEADERNAME:
	STRING|'<'('a'..'z'|'A'..'Z'|'.')+'>'
;
preprocessing_token: 
	IDENTIFIER|
	HEADERNAME|
	PPNUMBER|
//	CHARLITERAL|
	PPOPorPUNC 
;
else_group:
	'#else' new_line group?
;
endif_line:
	'#endif' new_line
;
control_line:
'#include' pp_tokens new_line |
'#define' IDENTIFIER replacement_list new_line|
'#define' IDENTIFIER lparen IDENTIFIER? ')' replacement_list new_line|
'#undef' IDENTIFIER new_line|
'#line' pp_tokens new_line|
'#error' pp_tokens? new_line|
'#pragma' pp_tokens? new_line|
 '#'new_line;

lparen:
	'('
;
replacement_list:
	pp_tokens?
;
pp_tokens:
	 preprocessing_token+
;

SIGN:
	'+'|'-'
;

// lex.charset



// lex.icon


terminal INTEGERLITERAL:
	'1'..'9' ('0'..'9')*(('u'|'U') ('l'|'L'|'ll'|'LL')? | ('l'|'L'|'ll'|'LL')('u'|'U')?)?|
	'0' ('0'..'7')*(('u'|'U') ('l'|'L'|'ll'|'LL')? | ('l'|'L'|'ll'|'LL')('u'|'U')?)?|
	('0x'|'0X') ('0'..'9'|'a'..'f'|'A'..'F')+(('u'|'U') ('l'|'L'|'ll'|'LL')? | ('l'|'L'|'ll'|'LL')('u'|'U')?)?
;

// lex.bool
terminal BOOLEANLITERAL:
	'false'|'true'
;

// lex.nullptr

terminal POINTERLITERAL:
	'nullptr'
;
// LEX.TOKEN

Token: 
	LITERAL |
	PPNUMBER |
	KEYWORD |
	PPOPorPUNC
;
// LEX.PPNUMBER === LEFT RECURSION REMOVED
 	
terminal PPNUMBER:  
 	(('0'..'9') | '.' ('0'..'9')) ('0'..'9'|('a'..'z'|'A'..'Z'|'_')| 'e'('+'|'-')|'E'('+'|'-')|'.')*;
 // LEX _ NAME === LEFT RECURSION REMOVED

terminal LITERAL:
	INTEGERLITERAL |
	BOOLEANLITERAL |
	POINTERLITERAL
;

// LEX.KEY
terminal KEYWORD:	  
 	'alignas'|
 	'alignof'| 
 	'asm'|
 	'auto'|
 	'bool'|
 	'break'|
 	'case'|
 	'catch'|
 	'char'|
 	'char16_t'|
 	'char32_t'|
 	'class'|
 	'const'|
 	'constexpr'|
 	'const_cast'|
 	'continue'|
 	'decltype'|
 	'default'|
 	'delete'|
 	'do'|
 	'double'|
 	'dynamic_cast'|
 	'else'|
 	'enum'|
 	'explicit'|
 	'export'|
 	'extern'|
 	'false'|
 	'float'|
 	'for'|
 	'friend'|
 	'goto'|
 	'if'|
 	'inline'|
 	'int'|
 	'long'|
 	'mutable'|
 	'namespace'|
 	'new'|
 	'noexcept'|
 	'nullptr'|
 	'operator'|
 	'private'|
 	'protected'|
 	'public'|
 	'register'|
 	'reinterpret_cast'|
 	'return'|
 	'short'|
 	'signed'|
 	'sizeof'|
 	'static'|
 	'static_assert'|
 	'static_cast'|
 	'struct'|
 	'switch'|
 	'template'|
 	'this'|
 	'thread_local'|
 	'throw'|
 	'true'|
 	'try'|
 	'typedef'|
 	'typeid'|
 	'typename'|
 	'union'|
 	'unsigned'|
 	'using'|
 	'virtual'|
 	'void'|
 	'volatile'|
 	'wchar_t'|
 	'while';
 	
 	
 	
// LEX.OPERATORS
// TODO(rigelbm): operator-token and punctuator
terminal PPOPorPUNC:
	'{'|
 	'}'|
 	'['|
 	']'|
 	'#'|
 	'##'|
 	'('|
 	')'|
 	'<:'|
 	':>'|
 	'<%'|
 	'%>'|
 	'%:'|
 	'%:%:'|
 	';'|
 	':'|
 	'...'|
 	'new'|
 	'delete'|
 	'?'|
 	'::'|
 	'.'|
 	'.*'|
 	'+'|
 	'-'|
 	'*'|
 	'/'|
 	'%'|
 	'^'|
 	'&'|
 	'|'|
 	'~'|
 	'!'|
 	'='|
 	'<'|
 	'>'|
 	'+='|
 	'-='|
 	'*='|
 	'/='|
 	'%='|
 	'^='|
 	'&='|
 	'|='|
 	'<<'|
 	'>>'|
 	'<<='|
 	'>>='|
 	'=='|
 	'!='|
 	'<='|
 	'>='|
 	'&&'|
 	'||'|
 	'++'|
 	'--'|
 	','|
 	'->*'|
 	'->'|
 	'and'|
 	'and_eq'|
 	'bitand'|
 	'bitor'|
 	'compl'|
 	'not'|
 	'not_eq'|
 	'or'|
 	'or_eq'|
 	'xor'|
 	'xor_eq';
 
 terminal IDENTIFIER:
	('a'..'z'|'A'..'Z'|'_') ('0'..'9'|'A'..'Z'|'a'..'z'|'_')*;
 	