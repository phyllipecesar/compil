grammar org.xtext.example.mydsl.MyDsl with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate myDsl "http://www.xtext.org/example/mydsl/MyDsl"

/*
 * SO FAR
 * 
 * LEX.PPNUMBER     [OK]
 * LEX.NAME         [OK]
 * LEX.KEY          [OK]
 * LEX.OPERATORS    [OK]
 * Lex.Token        [OK]
 *
 */

Model:
 	Body;

Body:
	{Body} preprocessing_file WS* new_line* (funcoes += FunctionDeclaration)*
;
FunctionDeclaration:
	{FunctionDeclaration} type=Type name=ID "(" 
		(params+=Parameter  ("," params+=Parameter)* )?  ")" "{"new_line		
		(escopo=statement)?
	"}";	
Parameter returns Symbol:
	{Parameter} type=Type name=ID;

VarDecl returns Symbol:
	{VarDecl} type=Type name=ID;

Type:
	simple_type_specifier;
simple_type_specifier:
	{IntType}"int"|
	{BoolType} "bool";

new_line:
	'\n' | '\r\n'
;
preprocessing_file:
	group?
;

group:
	group_part+
;

group_part:
	// pp_tokens? new_line |
	if_action |
	control_line;

if_action:
	if_group elif_groups? else_group? endif_line
;
if_group:
	'#if' constant_expression new_line group?|
	'#ifdef' ID new_line group?|
	'#ifndef' ID new_line group?
;
elif_groups:
	elif_group+;
	
elif_group:
  '#elif' constant_expression new_line group?;


//// A.5
statement:
//	expression_statement|
//	compound_statement|
//	jump_statement|
	{statement} variavel = declaration_statement
//	selection_statement
	;
//iteration_statement:
//	'while (' condition ')' statement|
//	'do' statement 'while ('expression ');'|
//	'for ( 'for_init_statement condition? ';' expression? ')' statement;
//
//for_init_statement:
//	expression_statement|simple_declaration;
//
simple_declaration:
	variavel = VarDecl ';' new_line
;
//expression_statement:
//	expression?
//;
//compound_statement:
//	'{' statement_seq? '}';
//	
//statement_seq:
//	(statement)+;
//selection_statement:
//	'if (' condition ')' statement |
//	'if (' condition ')' statement |
//	'switch (' condition ')' statement;
//
//
//// TODO(condition')
//condition:
//	expression
//;
//jump_statement:
//	'break;'|
//	'continue;'|
//	'return' expression?';'|
//	'goto' ID';'
//;
declaration_statement:
	(variaveis += block_declaration)+
;
//
//// TODO
block_declaration:
	{block_declaration} variavel = simple_declaration
;

constant_expression:
	conditional_expression;

conditional_expression:
		'TODO'
;
/* 	
conditional_expression:
//	logical_or_expression |
	logical_or_expression ('?' expression ':' assignment_expression)?;

logical_or_expression:
	logical_and_expression ('||' logical_and_expression )*;

logical_and_expression:
	inclusive_or_expression ('&&' inclusive_or_expression)*;

inclusive_or_expression:
	exclusive_or_expression ('|' exclusive_or_expression)*;

exclusive_or_expression:
	and_expression ('^' and_expression)*;

and_expression:
	equality_expression ('&' equality_expression)*;

equality_expression:
	relational_expression (('==' | '!=') relational_expression)*;

relational_expression:
	shift_expression (('<' | '>' | '<=' | '>=') shift_expression)*;

shift_expression:
	additive_expression (('<<' | '>>') additive_expression)*;

additive_expression:
	multiplicative_expression (SIGN multiplicative_expression)*;

multiplicative_expression:
	pm_expression (('*' | '/' | '%') pm_expression)*;

pm_expression:
	cast_expression (('.*' | '->*') cast_expression)*;

cast_expression:
	('(' ID ')')* unary_expression;
	//TODO replace ID with type_id, I guess

unary_expression:
	('sizeof')* postfix_expression |
	('sizeof')* ('++' | '--' | unary_operator ) cast_expression |
	'sizeof' '(' ID ')' |//TODO replace ID with type_id
	('sizeof')* new_expression |
	('sizeof')* delete_expression;

postfix_expression:
	primary_expression ('[' expression ']' |
						'(' expression_list? ')' |
						'.' 'template'? (ID) | //TODO replace ID with id_expression
						'->' 'template'? (ID) | //TODO replace ID with id_expression
						'++' |
						'--')*;

primary_expression:
	'==primary==';

pseudo_destructor_name:
	'::'? nested_name_specifier? type_name '::' '~' type_name |
	'::'? nested_name_specifier => 'template' template_id '::' '~' type_name;

nested_name_specifier:
	class_or_namespace_name '::' nested_name_specifier?;
//	class_or_namespace_name '::' => 'template' nested_name_specifier;
	

class_or_namespace_name:
	class_name | namespace_name;

class_name:
	ID | template_id;

namespace_name:
	'==namespace==';

type_name:
	'==type_name==';

template_id:
	ID '<' template_argument_list? '>' 'class';

template_argument_list:
	template_argument (',' template_argument)*;

template_argument:
	assignment_expression |
	id_expression;

id_expression:
	unqualified_id |
	qualified_id;

unqualified_id:
	ID |
	operator_function_id |
	conversion_function_id |
	'~' class_name |
	template_id;

operator_function_id:
	'operator' operator;

operator:
	'new' | 'delete' | 'new[]' | 'delete[]' | '+' | '-' | '*' | '/' | '%' | '^' | '&' | '|' | '~' | '!' | '=' | '<' | '>' |
	'+=' | '-=' | '*=' | '/=' | '%=' | '^=' | '&=' | '|=' | '<<' | '>>' | '<<=' | '>>=' | '==' | '!=' | '<=' | '>=' | '&&' |
	'||' | '++' | '--' | ',' | '->*' | '->' | '()' | '[]';

conversion_function_id:
	'operator' conversion_type_id;

conversion_type_id:
	type_specifier_seq conversion_declarator?;

conversion_declarator:
	'==conversion==';

type_specifier_seq:
	type_specifier+;

type_specifier:
	'==type_specifier==';

qualified_id:
	'==qualified==';

new_expression:
	'==new==';

delete_expression:
	'==delete==';

unary_operator:
	('*' | '&' | '+' | '-' | '!' | '~');

expression_list:
	assignment_expression (',' assignment_expression)*;

expression:
	'==expression==';

assignment_expression:
	'==assignment==';

*/


terminal HEADERNAME:
	STRING|'<'('a'..'z'|'A'..'Z'|'.')+'>'
;

preprocessing_token: 
	ID|
	HEADERNAME|
//	PPNUMBER|
//	CHARLITERAL|
	PREPROCESSING_OP_OR_PUNC
;
else_group:
	'#else' new_line group?
;
endif_line:
	'#endif' new_line
;
control_line:
'#include' pp_tokens new_line |
'#define' ID replacement_list new_line|
'#define' ID lparen ID? ')' replacement_list new_line|
'#undef' ID new_line|
'#line' pp_tokens new_line|
'#error' pp_tokens? new_line|
'#pragma' pp_tokens? new_line|
 '#'new_line;

lparen:
	'('
;
replacement_list:
	pp_tokens?
;
pp_tokens:
	 preprocessing_token+
;

SIGN:
	'+'|'-'
;// lex.charset
terminal fragment HEX_QUAD:
	HEXADECIMAL_DIGIT HEXADECIMAL_DIGIT HEXADECIMAL_DIGIT HEXADECIMAL_DIGIT;

terminal fragment UNIVERSAL_CHARACTER_NAME:
	'\\u' HEX_QUAD | '\\U' HEX_QUAD HEX_QUAD;

// lex.pptoken
PreProcessingToken:
	HEADER_NAME |
	ID |
	(DIGIT | '.' DIGIT) (DIGIT | NONDIGIT | ('e' | 'E') ('+' | '-') | '.')* |
	CHARACTER_LITERAL |
	STRING_LITERAL |
	PREPROCESSING_OP_OR_PUNC
	// each non-white-space character that cannot be one of the above [ambiguity!!!]
;

// lex.token
Token:
	KEYWORD |
	Literal |
	PREPROCESSING_OP_OR_PUNC
	ID;

// lex.header
terminal HEADER_NAME:
	'<' H_CHAR+ '>' | '\"' Q_CHAR+ '\"'
;

terminal fragment H_CHAR:
	!('\n' | '>');

terminal fragment Q_CHAR:
	!('\n' | '\"');


// lex.key
terminal KEYWORD:
	'alignas' |
	'alignof' |
	'asm' |
	'auto' |
	'bool' |
	'break' |
	'case' |
	'catch' |
	'char' |
	'char16_t' |
	'char32_t' |
	'class' |
	'const' |
	'constexpr' |
	'const_cast' |
	'continue' |
	'decltype' |
	'default' |
	'delete' |
	'do' |
	'double' |
	'dynamic_cast' |
	'else' |
	'enum' |
	'explicit' |
	'export' |
	'extern' |
	'false' |
	'float' |
	'for' |
	'friend' |
	'goto' |
	'if' |
	'inline' |
	'int' |
	'long' |
	'mutable' |
	'namespace' |
	'new' |
	'noexcept' |
	'nullptr' |
	'operator' |
	'private' |
	'protected' |
	'public' |
	'register' |
	'reinterpret_cast' |
	'return' |
	'short' |
	'signed' |
	'sizeof' |
	'static' |
	'static_assert' |
	'static_cast' |
	'struct' |
	'switch' |
	'template' |
	'this' |
	'thread_local' |
	'throw' |
	'true' |
	'try' |
	'typedef' |
	'typeid' |
	'typename' |
	'union' |
	'unsigned' |
	'using' |
	'virtual' |
	'void' |
	'volatile' |
	'wchar_t' |
	'while';

// lex.operators
terminal PREPROCESSING_OP_OR_PUNC:
	'{' |
	'}' |
	'[' |
	']' |
	'#' |
	'##' |
	'(' |
	')' |
	'<:' |
	':>' |
	'<%' |
	'%>' |
	'%:' |
	'%:%:' |
	';' |
	':' |
	'...' |
	'new' |
	'delete' |
	'?' |
	'::' |
	'.' |
	'.*' |
	'+' |
	'-' |
	'*' |
	'/' |
	'%' |
	'^' |
	'&' |
	'|' |
	'~' |
	'!' |
	'=' |
	'<' |
	'>' |
	'+=' |
	'-=' |
	'*=' |
	'/=' |
	'%=' |
	'^=' |
	'&=' |
	'|=' |
	'<<' |
	'>>' |
	'<<=' |
	'>>=' |
	'==' |
	'!=' |
	'<=' |
	'>=' |
	'&&' |
	'||' |
	'++' |
	'--' |
	',' |
	'->*' |
	'->' |
	'and' |
	'and_eq' |
	'bitand' |
	'bitor' |
	'compl' |
	'not' |
	'not_eq' |
	'or' |
	'or_eq' |
	'xor' |
	'xor_eq';

// lex.literal.kinds
Literal:
	INT |
	CHARACTER_LITERAL |
	FLOATING_LITERAL |
	STRING_LITERAL |
	('true' | 'false')
	//POINTER_LITERAL
	//USER_DEFINED_LITERAL
	;

// lex.icon
terminal INT returns ecore::EInt:
	(DECIMAL_LITERAL | OCTAL_LITERAL | HEXADECIMAL_LITERAL) INTEGER_SUFFIX?;

terminal fragment DECIMAL_LITERAL:
	'1'..'9' DIGIT*;

terminal fragment OCTAL_LITERAL:
	'0' OCTAL_DIGIT*;

terminal fragment HEXADECIMAL_LITERAL:
	('0x' | '0X') HEXADECIMAL_DIGIT+;

terminal fragment OCTAL_DIGIT:
	'0'..'7';

terminal fragment HEXADECIMAL_DIGIT:
	'0'..'9' | 'A'..'F';

terminal fragment INTEGER_SUFFIX:
	('u' | 'U') ('l' | 'L' | 'll' | 'LL')? |
	('l' | 'L' | 'll' | 'LL') ('u' | 'U')?;

// lex.ccon
terminal CHARACTER_LITERAL:
	('u' | 'U' | 'L')? '\'' C_CHAR+ '\'';

terminal fragment C_CHAR:
	!('\'' | '\\' | '\n') | ESCAPE_SEQUENCE | UNIVERSAL_CHARACTER_NAME;

terminal fragment ESCAPE_SEQUENCE:
	SIMPLE_ESCAPE_SEQUENCE | OCTAL_ESCAPE_SEQUENCE | HEXADECIMAL_ESCAPE_SEQUENCE;

terminal fragment SIMPLE_ESCAPE_SEQUENCE:
	'\\' ('\'' | '\"' | '?' | '\\' | 'a' | 'b' | 'f' | 'n' | 'r' | 't' | 'v');

terminal fragment OCTAL_ESCAPE_SEQUENCE:
	'\\' OCTAL_DIGIT OCTAL_DIGIT OCTAL_DIGIT;

terminal fragment HEXADECIMAL_ESCAPE_SEQUENCE:
	'\\x' HEXADECIMAL_DIGIT+;

// lex.name
terminal ID:
	(NONDIGIT | UNIVERSAL_CHARACTER_NAME) (DIGIT | NONDIGIT | UNIVERSAL_CHARACTER_NAME)*
;
terminal DIGIT:
	'0'..'9';

terminal NONDIGIT:
	'a'..'z' | 'A'..'Z' | '_';

// lex.fcon
terminal FLOATING_LITERAL:
	(FRACTIONAL_CONSTANT EXPONENT_PART? | DIGIT+ EXPONENT_PART) ('f' | 'l' | 'F' | 'L')?;

terminal fragment FRACTIONAL_CONSTANT:
	DIGIT* '.' DIGIT+ | DIGIT+ '.';

terminal fragment EXPONENT_PART:
	('e' | 'E') ('+' | '-')? DIGIT+;

// lex.string
terminal STRING_LITERAL:
	ENC_PREFIX? '\"' SCHAR+ '\"';

terminal fragment ENC_PREFIX:
	'u8' | 'u' | 'U' | 'L';

terminal fragment SCHAR:
	!('\"' | '\\' | '\n') | ESCAPE_SEQUENCE | UNIVERSAL_CHARACTER_NAME; 	